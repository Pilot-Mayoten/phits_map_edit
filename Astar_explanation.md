# A* (エースター) アルゴリズムによる経路探索について

このプロジェクトでは、スタート地点からゴール地点までの最適な経路を見つけるために、**A\* (エースター) アルゴリズム** を使用しています。このファイルでは、その仕組みと、このコード(`main.py`)における実装について解説します。

## 1. A* アルゴリズムとは？

A\* アルゴリズムは、グラフ（マス目のようなネットワーク構造）の中から最短経路を見つけ出すためのアルゴリズムの一つです。

有名な「ダイクストラ法」というアルゴリズムをベースに、「ゴールまであとどれくらいか？」という**ヒューリスティック（heuristics, 推定値）** を加えることで、より効率的に探索できるように改良されています。無駄な探索を減らし、高速に最適経路を見つけられるため、ゲームのキャラクター移動やカーナビのルート検索など、様々な場面で利用されています。

## 2. アルゴリズムの基本的な考え方

A\* アルゴリズムは、次に探索すべきマス（ノード）を評価するための**評価関数 `f(n)`** を用います。

$$
f(n) = g(n) + h(n)
$$

-   `g(n)`: **スタートからの実際のコスト**
    -   スタート地点から、今いるマス `n` まで移動するのに実際にかかったコスト（距離や時間など）。
-   `h(n)`: **ゴールまでの推定コスト（ヒューリスティック）**
    -   今いるマス `n` から、ゴール地点まで到達するのにかかると「予測される」コスト。あくまで推定値ですが、この精度が良いほど効率的に探索できます。

アルゴリズムは、この評価値 `f(n)` が最も小さいマスを優先的に探索していきます。これにより、ゴールへの見込みが薄い経路を後回しにし、効率的に最短経路にたどり着くことができます。

## 3. `main.py` における実装

このプロジェクトでは、A\* アルゴリズムを `run_astar` 関数内で実装しています。特徴的な点は、単なる距離だけでなく**放射線による被ばく線量もコストに含めている**ことです。

### コスト `g(n)` の計算

`main.py` では、1マス移動するごとのコストを以下のように計算しています。

```python
// ... existing code ...
# コスト = 移動(1) + 線量 * 重み
dose_val = dose_map[nr][nc] if dose_map else 0
new_cost = cost + 1 + (dose_val * weight)
// ... existing code ...
```

-   **`1`**: 1マス移動すること自体のコストです。これにより、移動距離が短い経路が優先されます。
-   **`dose_val * weight`**: そのマスで受ける線量 `dose_val` に、ユーザーが設定した重み `weight` を掛け合わせた値です。
    -   `weight` の値を大きくすると、線量を避けることをより重視した経路（多少遠回りしてでも安全な道）が選ばれやすくなります。
    -   `weight` を `0` にすると、線量を完全に無視して最短距離の経路を探します。

### ヒューリスティック `h(n)` の計算

ゴールまでの推定コストには、**マンハッタン距離** を採用しています。これは、斜め移動を考えず、縦と横の移動距離の合計を計算する方法です。

```python
// ... existing code ...
heuristic = abs(goal[0] - nr) + abs(goal[1] - nc)
// ... existing code ...
```

グリッド状のマップにおいて、障害物がない場合の最短移動量を示すため、効率的なヒューリスティックとしてよく用いられます。

### 障害物の扱い

マップ上で「壁 (障害物)」として設定されたマスは、探索経路から除外されます。

```python
// ... existing code ...
if self.map_data[nr][nc] == 1: continue # 壁
// ... existing code ...
```

### 探索の効率化

評価値 `f(n)` が最も小さいマスを効率的に見つけるため、Pythonの `heapq` モジュール（**優先度付きキュー**）を利用しています。これにより、毎回すべてのマスをチェックすることなく、最も有望なマスを高速に取り出すことができます。

```python
// ... existing code ...
import heapq

# ...

# キューへの追加 (ヒープに追加)
heapq.heappush(queue, (new_cost + heuristic, new_cost, next_pos, path + [next_pos]))

# キューからの取り出し (ヒープから最小値を取り出し)
_, cost, current, path = heapq.heappop(queue)
// ... existing code ...
```
